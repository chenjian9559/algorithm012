# 总结

> **算法源代码在每个项目里的program.cs 文件里** 

[高级动态规划](#高级动态规划)

[字符串算法](#字符串算法)

## 高级动态规划

1. 复杂问题分解
2. 最优子结构
3. 状态顺推

**回顾week 06 动态规划详情**

**关键点** 

​	动态规划 和 递归或者分治 没有根本上的区别（关键看有无最优的子结构）  

​	拥有共性：找到重复子问题  

​	差异性：最优子结构、中途可以淘汰次优解 

**高阶的 DP 问题**

复杂度来源 

1. 状态拥有更多维度（二维、三维、或者更多、甚至需要压缩）  
2. 状态方程更加复杂 

本质：内功、逻辑思维、数学

## 字符串算法

### 字符串匹配算法

1. 暴力法(brute force) - 0(mn)

2. Rabin-Karp算法

   在朴素算法中，我们需要挨个比较所有字符，才知道目标字符串中是否包含子串。那么，是否有别的方法可以用来判断目标字符串是否包含子串呢?

   答案是肯定的，确实存在-种更快的方法。为了避免挨个字符对目标字符串和子串进行比较，我们可以尝试次性判断两者 是否相等。因此，我们需要一个好的哈希函数(hash function)。通过哈希 函数，我们可以算出子串的哈希值,然后将它和目标字符串中的子串的哈希值进行比较。这个新方法在速度上比暴力法有显著提升。

   **Rabin-Karp算法的思想:**
   1.假设子串的长度为M (pat)， 目标字符串的长度为N (txt)
   2.计算子串的hash值hash_ _pat
   3.计算目标字符串txt中每个长度为M的子串的hash值(共需要计算N-M+1次)
   4.比较hash值:如果hash值不同，字符串必然不匹配;如果hash值相同，还需要使用朴素算法再次判断

3. KMP算法

   KMP算法(Knuth-Morris-Pratt) 的思想就是，当子串与目标字符串不匹配时，其实你已经知道了前面已经匹配成功那一部分的字符(包括子串与目标字符串)。以阮一峰的文章为例，当空格与D不匹配时，你其实知道前面六个字符是“ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把“搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。